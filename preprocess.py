import os
import re

import pandas as pd
import networkx as nx
import xml.etree.ElementTree as ET
import pickle
from networkx.drawing.nx_pydot import to_pydot
from scipy import sparse

from .querygraph import query_cypher

def rank_genes_groups2df(adata):
    """
    Converts the `rank_genes_groups` results from `scanpy` into a `DataFrame` format.

    This function extracts the gene ranking results from an `AnnData` object and 
    transforms them into a dictionary of `pandas.DataFrame` for further analysis.

    Args:
        adata (AnnData): An `AnnData` object containing the results of differential 
                         gene expression analysis (`sc.tl.rank_genes_groups()`).

    Returns:
        None: The converted data is stored in the `adata.uns['rank_genes_groups_df']` dictionary.
              Each category's `DataFrame` uses gene names as the index and includes the following columns:
              - `names`: Gene name
              - `scores`: Statistical score
              - `pvals`: p-value
              - `pvals_adj`: Adjusted p-value after multiple testing correction
              - `logfoldchanges`: Log fold change
              - `pts` (optional): Proportion of cells expressing the gene in the target group
              - `pts_rest` (optional): Proportion of cells expressing the gene in the rest of the dataset
    """

    tmp_dict = {}
    for para in ['names', 'scores', 'pvals', 'pvals_adj', 'logfoldchanges']:
        tmp_dict[para] = pd.DataFrame(adata.uns['rank_genes_groups'][para])

    ret_dict = {}
    for x in tmp_dict['names']:
        tmp = {}
        for para in ['names', 'scores', 'pvals', 'pvals_adj', 'logfoldchanges']:
            tmp[para] = tmp_dict[para][x]
        tmp = pd.DataFrame(tmp)
        tmp.index = tmp['names']
        if 'pts' in adata.uns['rank_genes_groups']:
            tmp['pts'] = adata.uns['rank_genes_groups']['pts'][x]
            tmp['pts_rest'] = adata.uns['rank_genes_groups']['pts_rest'][x]
        ret_dict[x] = tmp

    # ret_dict['params'] = adata.uns['rank_genes_groups']['params']
    adata.uns['rank_genes_groups_df'] = ret_dict
    #return ret_dict


def filter_marker(marker_df, sort_by='pts_delta', pvals_thres=0.05, pvals_adj_thres=0.05, topgenenumber=10):
    """
    Filters and ranks marker genes, returning the top-ranked gene list.

    This function selects genes from the differential gene expression dataset `marker_df` 
    that meet significance thresholds and sorts them based on the specified `sort_by` column.
    The function returns the top `topgenenumber` genes after filtering and sorting.

    Args:
        marker_df (pd.DataFrame): A DataFrame containing gene expression analysis results, 
                                  typically generated by `rank_genes_groups2df`.
                                  The DataFrame should include at least the following columns:
                                  - `names`: Gene name
                                  - `pvals`: p-value
                                  - `pvals_adj`: Adjusted p-value after multiple testing correction
                                  - `pts`: Proportion of cells expressing the gene in the target group
                                  - `pts_rest`: Proportion of cells expressing the gene in the background group
        sort_by (str, optional): The column used for sorting. Defaults to `'pts_delta'`, 
                                 which represents the expression proportion difference (`pts - pts_rest`).
                                 Available options:
                                 - `'pts_delta'`: Difference in expression proportion (`pts - pts_rest`)
                                 - `'scores'`: Gene ranking score
                                 - `'pvals'` or `'pvals_adj'`: p-values (sorted in ascending order by default)
        pvals_thres (float, optional): p-value threshold for filtering. Defaults to `0.05`.
        pvals_adj_thres (float, optional): Adjusted p-value threshold for filtering. Defaults to `0.05`.
        topgenenumber (int, optional): Number of top-ranked genes to return. Defaults to `10`.

    Returns:
        list: A list containing the top `topgenenumber` gene names after filtering and sorting.
    """
    neg_index = ['pvals', 'pvals_adj']
    if sort_by in neg_index:
        ascending = True
    else:
        ascending = False
    marker_df = marker_df.loc[marker_df['pvals'] <= pvals_thres]
    marker_df = marker_df.loc[marker_df['pvals_adj'] <= pvals_adj_thres]
    if sort_by == 'pts_delta':
        marker_df['pts_delta'] = marker_df['pts'] - marker_df['pts_rest']
    return list(marker_df.sort_values(sort_by, ascending=ascending).iloc[:topgenenumber]['names'])


def query_df2nxg(df, directed=False, reverse_direct=False):
    """
    Converts a query result DataFrame (`df`) into a NetworkX graph (`nx.Graph` or `nx.DiGraph`).

    This function transforms a DataFrame containing knowledge graph query results into 
    a network structure where nodes represent entities and edges represent relationships 
    between entities.

    Args:
        df (pd.DataFrame): A DataFrame containing query path results, typically retrieved 
                           from Neo4j or other knowledge graph databases.
                           The DataFrame must include the following columns:
                           - `path.0.name`: Name of the starting node in the path
                           - `path.0.type`: Type of the starting node
                           - `path.2.name`: Name of the ending node in the path
                           - `path.2.type`: Type of the ending node
        directed (bool, optional): Whether to create a directed graph. Defaults to `False` (undirected graph).
        reverse_direct (bool, optional): If `directed=True`, this parameter determines whether to 
                                         reverse the edge direction (making the endpoint point to the start point).
                                         Defaults to `False`.

    Returns:
        networkx.Graph or networkx.DiGraph: A NetworkX graph representing the query result.
    """
    if directed:
        nxg = nx.DiGraph()
    else:
        nxg = nx.Graph()

    for x, y in zip(df['path.0.name'], df['path.0.type']):
        if y == 'Gene':
            nxg.add_node(x, type=y)
        else:
            nxg.add_node(x, type="KG_" + y)

    for x, y in zip(df['path.2.name'], df['path.2.type']):
        if y == 'Gene':
            nxg.add_node(x, type=y)
        else:
            nxg.add_node(x, type="KG_" + y)

    for x, y in zip(df['path.0.name'], df['path.2.name']):
        if reverse_direct:
            nxg.add_edge(y, x)
        else:
            nxg.add_edge(x, y)
    return nxg


def count_df2nxg(df, directed=False, reverse_direct=False):
    """
    Converts a query result DataFrame (`df`) into a NetworkX graph (`nx.Graph` or `nx.DiGraph`).

    This function processes associations between genes and entities in a knowledge graph, 
    constructing a network representation:
    - `path.0.name` may contain multiple genes (in list format).
    - `path.2.name` represents target entities in the knowledge graph (e.g., diseases, drugs).
    - The resulting graph structure helps explore relationships between genes and 
      knowledge graph entities.

    Args:
        df (pd.DataFrame): A DataFrame containing query path results, typically retrieved 
                           from a knowledge graph database. The DataFrame must include:
                           - `path.0.name`: A list of genes, where each cell contains multiple genes.
                           - `path.2.name`: Entity names in the knowledge graph (e.g., diseases, drugs).
                           - `path.2.type`: The type of knowledge graph entity (e.g., `'Disease'`, `'Drug'`).
        directed (bool, optional): Whether to create a directed graph. Defaults to `False` (undirected graph).
        reverse_direct (bool, optional): If `directed=True`, this parameter determines whether to 
                                         reverse the edge direction (making the endpoint point to the start point).
                                         Defaults to `False`.

    Returns:
        networkx.Graph or networkx.DiGraph: A NetworkX graph representing the query result.
    """
    if directed:
        nxg = nx.DiGraph()
    else:
        nxg = nx.Graph()

    tmp = set()
    for x in df['path.0.name']:
        for y in x:
            tmp.add(y)
    for x in tmp:
        nxg.add_node(x, type='Gene')
    for x, y in zip(df['path.2.name'], df['path.2.type']):
        nxg.add_node(x, type="KG_"+y)

    for x, y in zip(df['path.0.name'], df['path.2.name']):
        for z in x:
            if reverse_direct:
                nxg.add_edge(y, z)
            else:
                nxg.add_edge(z, y)
    return nxg


def df2nxg(df, directed=False, reverse_direct=False):
    """
    Converts a query result DataFrame (`df`) into a NetworkX graph (`nx.Graph` or `nx.DiGraph`).

    This function determines whether the input DataFrame represents gene-entity associations 
    or general entity relationships and selects the appropriate conversion method:
    - If `path.0.name` contains a list (indicating multiple genes per entry), 
      it calls `count_df2nxg()` to construct a gene-to-entity network.
    - Otherwise, it calls `query_df2nxg()` to create a general knowledge graph.

    Args:
        df (pd.DataFrame): A DataFrame containing query path results from a knowledge graph database.
                           It must contain the column `path.0.name`.
        directed (bool, optional): Whether to create a directed graph. Defaults to `False` (undirected graph).
        reverse_direct (bool, optional): If `directed=True`, this parameter determines whether to 
                                         reverse the edge direction (making the endpoint point to the start point).
                                         Defaults to `False`.

    Returns:
        networkx.Graph or networkx.DiGraph: A NetworkX graph representing the query result.
    """
    tmp = list(df['path.0.name'])[0]
    if isinstance(tmp, list):
        return count_df2nxg(df, directed=directed, reverse_direct=reverse_direct)
    else:
        return query_df2nxg(df, directed=directed, reverse_direct=reverse_direct)


def adata2nxg(adata, directed=False, reverse_direct=False, cell_neighbor=False):
    """
    Converts an AnnData (`adata`) object into a NetworkX graph (`nx.Graph` or `nx.DiGraph`).

    This function constructs a network representation of single-cell transcriptomics data, including:
    - Cell-gene expression relationships (extracted from `adata.X`).
    - Optional cell-cell adjacency relationships (extracted from `adata.obsp['connectivities']` if `cell_neighbor=True`).

    Args:
        adata (AnnData): A single-cell data object that must contain:
            - `adata.X`: Cell-gene expression matrix (in sparse matrix format).
            - `adata.obs_names`: Cell names.
            - `adata.var_names`: Gene names.
            - `adata.obsp['connectivities']` (optional): Cell adjacency matrix (used when `cell_neighbor=True`).
        directed (bool, optional): Whether to create a directed graph. Defaults to `False` (undirected graph).
        reverse_direct (bool, optional): If `directed=True`, this parameter determines whether to reverse 
                                         the edge direction (making the endpoint point to the start point).
                                         Defaults to `False`.
        cell_neighbor (bool, optional): Whether to add cell-cell adjacency relationships based on 
                                        `adata.obsp['connectivities']`. Defaults to `False`.

    Returns:
        networkx.Graph or networkx.DiGraph: A NetworkX graph representing the single-cell data.
    """
    if sparse.issparse(adata.X):
        expr = adata.X.tocoo()
    else:
        expr = sparse.coo_array(adata.X)
        print('adata.X seems not a sparse matrix, please check whether the adata.X is raw count or log normalized count')
    Omics_edges = []
    Omics_nodes = {}

    celllist = adata.obs_names
    genelist = adata.var_names

    for x in genelist:
        Omics_nodes[x] = {'type': 'Gene'}

    for x in celllist:
        Omics_nodes[x] = {'type': 'Omics_Cell'}

    for x, y in zip(expr.row, expr.col):
        Omics_edges.append([celllist[x], genelist[y]])

    if cell_neighbor:
        if 'connectivities' in adata.obsp:
            neighbor = adata.obsp['connectivities'].tocoo()
            for x, y in zip(neighbor.row, neighbor.col):
                Omics_edges.append([celllist[x], celllist[y]])
        else:
            print('the adata must run sc.pp.neighbor first when cell_neighbor=True, skipping cell neighbor edges')

    Omics_nodes = [[x, y] for x, y in Omics_nodes.items()]
    if directed:
        nxg = nx.DiGraph()
    else:
        nxg = nx.Graph()
    #nxg = nx.Graph()
    nxg.add_nodes_from(Omics_nodes)
    if reverse_direct:
        nxg.add_edges_from(Omics_edges)
    else:
        nxg.add_edges_from([x[::-1] for x in Omics_edges])
    return nxg

def paga2nx(adata):
    """ 
    Converts PAGA (Partition-based Graph Abstraction) results into a NetworkX graph (`nx.MultiDiGraph`).

    This function constructs a graph structure representing cell clusters based on PAGA results computed by Scanpy. 
    The generated graph supports visualization and further analysis.

    Args:
        adata (AnnData): A single-cell data object that must contain:
            - `adata.uns['paga']['connectivities_tree']`: A sparse matrix representing the cluster connectivity graph computed by PAGA.
            - `adata.uns['paga']['groups']`: The name of the `obs` column indicating cluster group assignments.
            - `adata.uns[f'{group}_colors']`: Color information for each cluster.

    Returns:
        networkx.MultiDiGraph: A directed multigraph containing cluster nodes and weighted edges representing connectivity.
    """
    baseline_size_max = 10
    baseline_size = 20
    baseline_weight_max = 5
    baseline_weight = 10
    
    adj = pd.DataFrame(adata.uns['paga']['connectivities_tree'].todense())
    group = adata.uns['paga']['groups']

    categories = adata.obs[group].cat.categories

    adj.columns = adata.obs[group].cat.categories
    adj.index = adata.obs[group].cat.categories

    #print("Categories:", categories)
    #print("Adjacency matrix index:", adj.index)
    #print("Adjacency matrix columns:", adj.columns)

    adj = adj.loc[categories, categories]

    G = nx.from_pandas_adjacency(adj, create_using=nx.MultiDiGraph)
    
    name2color = {x: y for x, y in zip(categories, adata.uns[f'{group}_colors'])}
    
    tmp = adata.obs.copy()
    tmp['0'] = 0
    tmp = tmp[[group, '0']]
    name2size = tmp.groupby(group).count().to_dict()['0']
    max_size = max(name2size.values())
    name2size = {x: y * baseline_size_max / max_size + baseline_size for x, y in name2size.items()}
    
    for x in G.nodes:
        G.nodes[x]['original_name'] = x
        G.nodes[x]['color'] = name2color[x]
        G.nodes[x]['size'] = name2size[x]
    
    for edge in G.edges:
        e = G.edges[edge]
        e['weight'] = e['weight'] * baseline_weight_max + baseline_weight
        e['color'] = 'black'
        e['arrows'] = False

    return G

def combine_graph(adata, df, directed=False, omics_reverse_direct=False, kg_reverse_direct=False, cell_neighbor=False):
    """ 
    Constructs an integrated network graph by combining single-cell omics data (`adata`) and a knowledge graph (`df`).

    This function merges single-cell transcriptomics data with knowledge graph data to create a unified `networkx` graph 
    for further analysis and visualization.

    Args:
        adata (AnnData): An `AnnData` object containing single-cell transcriptomics data.
        df (pandas.DataFrame): A DataFrame containing edge data from a knowledge graph.
        directed (bool, optional): Whether to create a directed graph. Defaults to `False`.
        omics_reverse_direct (bool, optional): Whether to reverse the edge direction in the omics network. Defaults to `False`.
        kg_reverse_direct (bool, optional): Whether to reverse the edge direction in the knowledge graph network. Defaults to `False`.
        cell_neighbor (bool, optional): Whether to include cell-cell adjacency information (adds edges between neighboring cells). Defaults to `False`.

    Returns:
        networkx.Graph or networkx.DiGraph: An integrated network graph combining single-cell data and the knowledge graph.
    """
    Omics_Graph = adata2nxg(adata, directed=directed, reverse_direct=omics_reverse_direct, cell_neighbor=cell_neighbor)
    KG_Graph = df2nxg(df, directed=directed, reverse_direct=kg_reverse_direct)
    return nx.compose(Omics_Graph, KG_Graph)

def extract_genes(target_genes_str):
    """ 
    Extracts gene names from a string and returns a unique set of genes.

    This function parses a string containing a list of gene names and extracts them. 
    It is typically used to retrieve gene information from text-based query results.

    Args:
        target_genes_str (str): A string containing gene names, typically formatted as `("GeneA", "GeneB", "GeneC")`.

    Returns:
        set: A set of unique gene names extracted from the input string.
    """
    matches = re.findall(r"\('([^']+)'", target_genes_str)
    return set(matches)

def get_verified_tf(module_file,gene_list):
    """ 
    Parses a transcription factor (TF) regulation file and filters TFs that overlap with a given gene list.

    This function extracts TFs and their target genes from a provided regulation module file (CSV/TSV format) 
    and identifies TFs whose target genes intersect with the input gene list.

    Args:
        module_file (str): Path to the file containing transcription factor (TF) information (CSV or TSV format).
        gene_list (list): A list of target genes to find overlapping TF-associated genes.

    Returns:
        pd.DataFrame: A DataFrame containing TFs and their target genes that overlap with the input gene list, 
                      sorted in descending order of overlap size.
    """
    file_extension = module_file.split('.')[-1].lower()
    if file_extension == 'tsv':
        module_df = pd.read_csv(f"{module_file}", sep="\t")
    elif file_extension == 'csv':
        module_df = pd.read_csv(f"{module_file}")
    
    module_df = module_df.rename(columns={"Unnamed: 0": "TF", "Enrichment.6": "TargetGenes"})
    module_df = module_df[["TF", "TargetGenes"]].dropna()

    module_df["RegulonGenes"] = module_df["TargetGenes"].apply(extract_genes)
    #print(module_df.head())

    intersection_dict = {}

    gene_list = set(gene_list)

    for _, row in module_df.iterrows():
        tf = row["TF"]
        regulon_genes = row["RegulonGenes"]
        intersection = gene_list.intersection(regulon_genes)
        intersection_dict[tf] = {
            "OverlappingGenes": intersection,
            "IntersectionSize": len(intersection),
            "Regulon":regulon_genes
        }

    intersection_df = pd.DataFrame.from_dict(intersection_dict, orient="index")
    intersection_df = intersection_df.sort_values(by="IntersectionSize", ascending=False)
    return intersection_df

""" def remove_namespace(tree):
    for elem in tree.iter():
        if '}' in elem.tag:
            elem.tag = elem.tag.split('}', 1)[1]
        elem.attrib = {key.split('}', 1)[-1]: value for key, value in elem.attrib.items()}
    return tree """

def remove_namespace(tree):
    """
    Removes namespaces from the XML tags in the given ElementTree.

    This helper function iterates over all elements in the tree and strips out the namespace prefix 
    (if present) from each element's tag, which allows for easier processing of XML elements in SVG files.

    Args:
        tree (xml.etree.ElementTree): The ElementTree object representing the SVG file.

    Returns:
        xml.etree.ElementTree: The modified ElementTree object with namespaces removed from the tags.
    """
    for elem in tree.iter():
        if '}' in elem.tag:
            elem.tag = elem.tag.split('}', 1)[1]
    return tree

def read_svg_graph(svg_file, node_class='node', edge_class='edge', default_node_color='black', default_edge_color='black'):
    """
    Parses an SVG graph file and constructs a NetworkX graph object.

    This function reads the nodes and edges from an SVG file and converts them into a NetworkX `MultiDiGraph` (multiplex directed graph),
    suitable for extracting network structures from visualized graphs, such as biological networks or knowledge graphs.

    Args:
        svg_file (str): Path to the SVG file.
        node_class (str): The `class` attribute value used to identify nodes (default: `'node'`).
        edge_class (str): The `class` attribute value used to identify edges (default: `'edge'`).
        default_node_color (str): Default color for nodes (default: `'black'`).
        default_edge_color (str): Default color for edges (default: `'black'`).

    Returns:
        nx.MultiDiGraph: The graph representation of the parsed SVG.
    """
    tree = ET.parse(svg_file)
    tree = remove_namespace(tree)
    root = tree.getroot()
    
    G = nx.MultiDiGraph()

    for node in root.findall(f".//g[@class='{node_class}']"):
        title = node.find('title')
        title_text = title.text.strip() if title is not None else None

        shape = None
        color = default_node_color

        for shape_tag in ['ellipse', 'polygon', 'circle', 'rect']:
            element = node.find(shape_tag)
            if element is not None:
                shape = shape_tag
                color = element.attrib.get('stroke', default_node_color)
                break

        if title_text:
            G.add_node(title_text, shape=shape, color=color)

    for edge in root.findall(f".//g[@class='{edge_class}']"):
        title = edge.find('title')
        title_text = title.text.strip() if title is not None else None
        path = edge.find('path')

        color = default_edge_color
        if path is not None:
            color = path.attrib.get('stroke', default_edge_color)

        if title_text and '->' in title_text:
            source, target = map(str.strip, title_text.split('->'))
            G.add_edge(source, target, color=color)

    return G

def save_pkl_file(graph,file_name):
    """
    Saves a NetworkX graph or any Python object as a `.pkl` file.

    This function uses the `pickle` library to serialize the given Python object and save it to the specified path.
    It is suitable for saving structured data such as NetworkX graphs, dictionaries, lists, etc.

    Args:
        graph (Any): The Python object to be saved (e.g., a NetworkX graph).
        file_name (str): The name of the file to save the object to (without the `.pkl` extension).
    
    Returns:
        None
    """
    with open(f"{file_name}.pkl", "wb") as f:
        pickle.dump(graph, f)

def save_svg_file(pydot_graph,file_name):
    """ 
    Saves a PyDot graph object as a `.svg` file.

    This function uses the `write_svg()` method from the `pydot` library to store the generated graph as an SVG file.
    It is suitable for visualizing graph structures, such as **gene regulatory networks**, **knowledge graphs**, etc.

    Args:
        pydot_graph (pydot.Dot): The PyDot graph object to be saved.
        file_name (str): The file name to save the graph to (should include the `.svg` extension).

    Returns:
        None
    """
    pydot_graph.write_svg(file_name)

def save_pdf_file(pydot_graph,file_name):
    """ 
    Saves a PyDot graph object as a `.pdf` file.

    This function uses the `write_pdf()` method from the `pydot` library to export the generated graph in PDF format.
    It is suitable for visualizing **gene regulatory networks**, **protein-protein interaction (PPI) networks**, and **knowledge graphs**.

    Args:
        pydot_graph (pydot.Dot): The PyDot graph object to be saved.
        file_name (str): The file name to save the graph to (should include the `.pdf` extension).

    Returns:
        None
    """
    pydot_graph.write_pdf(file_name)

def save_graphml_file(graph, file_name):
    """ 
    Saves a NetworkX graph object as a `.graphml` file.

    `GraphML` is an XML-based graph data format suitable for storing and exchanging **gene regulatory networks**, 
    **protein-protein interaction (PPI) networks**, **metabolic pathways**, and **knowledge graphs (KG)**.

    Args:
        graph (networkx.Graph or networkx.DiGraph): The NetworkX graph object to be saved.
        file_name (str): The file name to save the graph to (extension `.graphml` will be added automatically).

    Returns:
        None
    """
    nx.write_graphml(graph, f"{file_name}.graphml")

def save_graph(graph, file_name):
    """ 
    A general-purpose graph saving function that can save a NetworkX graph object in various formats (`pkl`, `svg`, `pdf`, `graphml`).

    Args:
        graph (networkx.Graph or networkx.DiGraph): The NetworkX graph object to be saved.
        file_name (str): The file name to save the graph to (must include the extension, such as `network.pkl`, `graph.svg`).

    Returns:
        None
    """
    file_format = file_name.split(".")[-1]

    for u, v, data in graph.edges(data=True):
        if "color" in data:
            if data["color"] == "green":
                data["arrowhead"] = "normal"
            else:
                data["arrowhead"] = "none"

    if file_format == "pkl":
        save_pkl_file(graph,file_name)

    elif file_format == "svg":
        pydot_graph = to_pydot(graph)
        save_svg_file(pydot_graph,file_name)

    elif file_format == "pdf":
        pydot_graph = to_pydot(graph)
        save_pdf_file(pydot_graph,file_name)

    elif file_format == "graphml":
        save_graphml_file(graph, file_name)
    else:
        raise ValueError("Unsupported format. Use 'pkl', 'svg', 'pdf', or 'graphml'.")
        
    print(f"Graph successfully saved to {file_name}.{file_format}")

def read_pkl_graph(pkl_file):
    """
    Reads a `.pkl` file and deserializes it into a NetworkX graph object.

    Args:
        pkl_file (str): The file name of the `.pkl` file, including the path (e.g., `"network.pkl"`).

    Returns:
        networkx.Graph or networkx.DiGraph: The deserialized NetworkX graph object.
    """
    with open(pkl_file, 'rb') as f:
        graph = pickle.load(f)
    return graph

def read_graphml_graph(graphml_file):
    """
    Reads a `.graphml` file and converts it into a NetworkX graph object.

    Args:
        graphml_file (str): The file path of the `.graphml` file to read.

    Returns:
        networkx.Graph or networkx.DiGraph: The parsed NetworkX graph object.
    """
    return nx.read_graphml(graphml_file)

def read_graph(file_path):
    """ 
    Reads a graph file in various formats and converts it into a NetworkX graph object.

    Args:
        file_path (str): The path to the graph file to read. Supports `.svg`, `.pkl`, and `.graphml` formats.

    Returns:
        networkx.Graph or networkx.DiGraph: The parsed NetworkX graph object.
    """
    ext = os.path.splitext(file_path)[-1].lower()

    if ext == '.svg':
        return read_svg_graph(file_path)
    elif ext == '.pkl':
        return read_pkl_graph(file_path)
    elif ext == '.graphml':
        return read_graphml_graph(file_path)
    else:
        raise ValueError(f"Unsupported file format: {ext}")

def filter_results(qg: nx.MultiDiGraph) -> list:
    """Processes query result graph to extract normalized path information.
    
    Filters cell-type nodes, handles relationship directions, and deduplicates paths.
    Specifically reverses 'is_a' relationships for consistent hierarchy representation.

    Args:
        qg (nx.MultiDiGraph): Query graph returned by BRICK's query_shortest_path

    Returns:
        list: Deduplicated list of tuples representing filtered paths in format:
            (source_name, relation_type, target_name)

    Note:
        - Only processes nodes with 'Cell' type and valid 'name' attribute
        - Automatically reverses direction for 'is_a' relationships
        - Ensures unique path entries through in-process deduplication
    """
    id_to_name = {n: qg.nodes[n]['name'] 
                 for n in qg.nodes if 
                 'name' in qg.nodes[n] and 
                 qg.nodes[n].get('type') == 'Cell'}
    
    paths = []
    for source_id, target_id, edge_data in qg.edges(data=True):
        if source_id not in id_to_name or target_id not in id_to_name:
            continue
        
        source_name = id_to_name[source_id]
        target_name = id_to_name[target_id]
        relation = edge_data.get('relation', 'unknown')

        if relation == "is_a":
            path_tuple = (target_name, relation, source_name) 
        else:
            path_tuple = (source_name, relation, target_name)

        if path_tuple not in paths:
            paths.append(path_tuple)
            
    return paths

def complete_results(filtered_paths: list, original_graph: nx.Graph, node_attrs: dict,  edge_attrs: dict) -> nx.MultiDiGraph:
    """Constructs annotated graph combining original data and query results.
    
    Creates MultiDiGraph with:
    1. Original node attributes preserved
    2. Filtered paths added as edges with specified attributes
    3. Visual highlighting for disconnected original edges

    Args:
        filtered_paths (list): Processed paths from filter_results()
        original_graph (nx.Graph): Base graph containing original node/edge data
        node_attrs (dict): Default attributes for new nodes added via paths
        edge_attrs (dict): Default styling for edges representing filtered paths

    Returns:
        nx.MultiDiGraph: Consolidated graph showing:
        - Gray: Original nodes with preserved attributes
        - Black edges: Inferred relationships from query results
        - Red edges: Original edges without connecting paths in results

    Note:
        - Always preserves original node data when present
        - New nodes from paths receive node_attrs if not in original
        - Red edges use non-directional visualization (arrows='none')
    """
    G = nx.MultiDiGraph()

    for n, data in original_graph.nodes(data=True):
        G.add_node(n,**data)

    for s, r, t in filtered_paths:
        G.add_node(s,**node_attrs) if s not in G else None
        G.add_node(t, **node_attrs) if t not in G else None
        G.add_edge(s, t, **edge_attrs)

    for s, t in original_graph.edges():
        if not (nx.has_path(G,s,t) or nx.has_path(G,t,s)):
            G.add_edge(s, t, color='red', weight=2, arrows='none')
    return G

__all__ = ["rank_genes_groups2df", "filter_marker", "df2nxg", "get_verified_tf", "read_graph", "save_graph"]  # 明确指定对外公开的函数